#![allow(unused_imports, non_snake_case, non_camel_case_types, non_upper_case_globals, unused_parens, non_shorthand_field_patterns, dead_code, overflowing_literals, clippy::ptr_arg)]

extern crate fnv;
extern crate differential_dataflow;
extern crate observe;
extern crate timely;
extern crate num_traits;

#[macro_use]
extern crate lazy_static;

#[macro_use]
extern crate serde;
extern crate libc;
extern crate twox_hash;

#[macro_use]
extern crate differential_datalog;

#[macro_use]
extern crate abomonation;
extern crate ddlog_ovsdb_adapter;

#[cfg(feature="flatbuf")]
extern crate flatbuffers;

use differential_dataflow::collection;
use timely::dataflow::scopes;
use timely::worker;
use timely::communication;

use differential_datalog::program::*;
use differential_datalog::uint::*;
use differential_datalog::int::*;
use differential_datalog::arcval;
use differential_datalog::record;
use differential_datalog::record::{FromRecord, IntoRecord, Mutator};
use abomonation::Abomonation;

use fnv::{FnvHashSet, FnvHashMap};
use std::fmt::Display;
use std::fmt;
use std::sync;
use std::hash::Hash;
use std::hash::Hasher;
use std::os::raw;
use std::borrow;
use std::ptr;
use std::ffi;
use std::boxed;
use std::fs;
use std::ops::Deref;
use std::io::Write;
use std::os::unix;
use std::os::unix::io::{IntoRawFd, FromRawFd};
use std::mem;
use num_traits::identities::One;
use libc::size_t;

pub mod valmap;
pub mod update_handler;
pub mod ovsdb;
pub mod api;
pub mod server;

/* FlatBuffers bindings generated by `ddlog` */
#[cfg(feature="flatbuf")]
pub mod flatbuf;

/* FlatBuffers code generated by `flatc` */
#[cfg(feature="flatbuf")]
pub mod flatbuf_generated;


pub fn string_append_str(mut s1: String, s2: &str) -> String
{
    s1.push_str(s2);
    s1
}

pub fn string_append(mut s1: String, s2: &String) -> String
{
    s1.push_str(s2.as_str());
    s1
}


pub use __std::*;
mod __std {
    use super::*;
    /// Rust implementation of DDlog standard library functions and types.
    
    extern crate num;
    
    use differential_datalog::arcval;
    use differential_datalog::record::*;
    
    use std::fmt::Display;
    use std::fmt;
    use std::hash::Hash;
    use std::hash::Hasher;
    use twox_hash::XxHash;
    use std::vec;
    use std::collections::btree_set;
    use std::collections::btree_map;
    use std::vec::{Vec};
    use std::collections::{BTreeMap, BTreeSet};
    use std::iter::FromIterator;
    use std::ops;
    use std::cmp;
    use std::marker;
    use std::slice;
    
    /* FlatBuffers bindings generated by `ddlog` */
    #[cfg(feature="flatbuf")]
    use flatbuf::{FromFlatBuffer, ToFlatBuffer, ToFlatBufferTable, ToFlatBufferVectorElement, FBIter};
    
    /* FlatBuffers runtime */
    #[cfg(feature="flatbuf")]
    use flatbuffers as fbrt;
    
    const XX_SEED1: u64 = 0x23b691a751d0e108;
    const XX_SEED2: u64 = 0x20b09801dce5ff84;
    
    // Ref
    pub type std_Ref<A> = arcval::ArcVal<A>;
    
    pub fn std_ref_new<A: Clone>(x: &A) -> std_Ref<A> {
        arcval::ArcVal::from(x.clone())
    }
    
    pub fn std_deref<A: Clone>(x: &std_Ref<A>) -> &A {
        x.deref()
    }
    
    #[cfg(feature="flatbuf")]
    impl <T,FB> FromFlatBuffer<FB> for std_Ref<T>
    where
    T: FromFlatBuffer<FB>
    {
        fn from_flatbuf(fb: FB) -> Response<Self> {
            Ok(std_Ref::from(T::from_flatbuf(fb)?))
        }
    }
    
    #[cfg(feature="flatbuf")]
    impl <'b, T> ToFlatBuffer<'b> for std_Ref<T>
    where
    T: ToFlatBuffer<'b>,
    {
        type Target = T::Target;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            self.deref().to_flatbuf(fbb)
        }
    }
    
    #[cfg(feature="flatbuf")]
    impl <'b, T> ToFlatBufferTable<'b> for std_Ref<T>
    where
    T: ToFlatBufferTable<'b>,
    {
        type Target = T::Target;
    
        fn to_flatbuf_table(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> fbrt::WIPOffset<Self::Target> {
            self.deref().to_flatbuf_table(fbb)
        }
    }
    
    #[cfg(feature="flatbuf")]
    impl <'b, T> ToFlatBufferVectorElement<'b> for std_Ref<T>
    where
    T: ToFlatBufferVectorElement<'b>,
    {
        type Target = T::Target;
    
        fn to_flatbuf_vector_element(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            self.deref().to_flatbuf_vector_element(fbb)
        }
    }
    
    // min/max
    pub fn std_max<A: Ord + Clone>(x: &A, y: &A) -> A {
        if *x >= *y {
            x.clone()
        } else {
            y.clone()
        }
    }
    
    pub fn std_min<A: Ord + Clone>(x: &A, y: &A) -> A {
        if *x <= *y {
            x.clone()
        } else {
            y.clone()
        }
    }
    
    // Arithmetic functions
    pub fn std_pow32<T: num::One + ops::Mul + Clone>(base: &T, exp: &u32) -> T {
        num::pow::pow(base.clone(), *exp as usize)
    }
    
    // Option
    pub fn option2std<T: Clone>(x: Option<T>) -> std_Option<T> {
        match x {
            None => std_Option::std_None,
            Some(v) => std_Option::std_Some{x: v}
        }
    }
    
    // Range
    pub fn std_range<A: Clone + Ord + ops::Add<Output = A> + PartialOrd>(from: &A, to: &A, step: &A) -> std_Vec<A> {
        let mut vec = std_Vec::new();
        let mut x = from.clone();
        while x <= *to {
            vec.push(x.clone());
            x = x + step.clone();
        };
        vec
    }
    
    // Vector
    
    #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
    pub struct std_Vec<T> {
        pub x: Vec<T>
    }
    
    /* This is needed so we can support for-loops over `Vec`'s
     */
    pub struct VecIter<'a, X> {
        iter: slice::Iter<'a, X>
    }
    
    impl<'a, X> VecIter<'a, X> {
        pub fn new(vec: &'a std_Vec<X>) -> VecIter<'a, X> {
            VecIter{iter: vec.x.iter()}
        }
    }
    
    impl<'a, X> Iterator for VecIter<'a, X> {
        type Item = &'a X;
    
        fn next(&mut self) -> Option<Self::Item> {
            self.iter.next()
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl <'a, T> std_Vec<T> {
        pub fn iter(&'a self) -> VecIter<'a, T> {
            VecIter::new(self)
        }
    }
    
    impl <T> std_Vec<T> {
        pub fn new() -> Self {
            std_Vec{x: Vec::new()}
        }
        pub fn with_capacity(capacity: usize) -> Self {
            std_Vec{x: Vec::with_capacity(capacity)}
        }
        pub fn push(&mut self, v: T) {
            self.x.push(v);
        }
    }
    
    impl <T: Clone> std_Vec<T> {
        pub fn extend_from_slice(&mut self, other: &[T]) {
            self.x.extend_from_slice(other);
        }
    }
    
    impl<T: FromRecord> FromRecord for std_Vec<T> {
        fn from_record(val: &Record) -> Result<Self, String> {
            Vec::from_record(val).map(|x|std_Vec{x})
        }
    }
    
    impl<T: IntoRecord> IntoRecord for std_Vec<T> {
        fn into_record(self) -> Record {
            self.x.into_record()
        }
    }
    
    impl<T: FromRecord> Mutator<std_Vec<T>> for Record
    {
        fn mutate(&self, vec: &mut std_Vec<T>) -> Result<(), String> {
            self.mutate(&mut vec.x)
        }
    }
    
    impl<T: Display> Display for std_Vec<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{}", *v))?;
                if i < len-1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<T: fmt::Debug> fmt::Debug for std_Vec<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{:?}", *v))?;
                if i < len-1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<T> IntoIterator for std_Vec<T> {
        type Item = T;
        type IntoIter = vec::IntoIter<T>;
        fn into_iter(self) -> Self::IntoIter {
            self.x.into_iter()
        }
    }
    
    
    #[cfg(feature="flatbuf")]
    impl <'a,T,F> FromFlatBuffer<fbrt::Vector<'a,F>> for std_Vec<T>
    where
    T: Ord+FromFlatBuffer<F::Inner>,
    F: fbrt::Follow<'a> + 'a,
    {
        fn from_flatbuf(fb: fbrt::Vector<'a,F>) -> Response<Self> {
            let mut vec = std_Vec::with_capacity(fb.len());
            for x in FBIter::from_vector(fb) {
                vec.push(T::from_flatbuf(x)?);
            };
            Ok(vec)
        }
    }
    
    // For scalar types, the FlatBuffers API returns slice instead of 'Vector'.
    #[cfg(feature="flatbuf")]
    impl <'a,T> FromFlatBuffer<&'a [T]> for std_Vec<T>
    where
    T: Clone
    {
        fn from_flatbuf(fb: &'a [T]) -> Response<Self> {
            let mut vec = std_Vec::with_capacity(fb.len());
            vec.extend_from_slice(fb);
            Ok(vec)
        }
    }
    
    #[cfg(feature="flatbuf")]
    impl <'b, T> ToFlatBuffer<'b> for std_Vec<T>
    where
    T: ToFlatBufferVectorElement<'b>,
    {
        type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T::Target as fbrt::Push>::Output>>;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            let vec: Vec<T::Target> = self.iter().map(|x|x.to_flatbuf_vector_element(fbb)).collect();
            fbb.create_vector(vec.as_slice())
        }
    }
    
    pub fn std_vec_len<X: Ord + Clone>(v: &std_Vec<X>) -> u64 {
        v.x.len() as u64
    }
    
    pub fn std_vec_empty<X: Ord + Clone>() -> std_Vec<X> {
        std_Vec::new()
    }
    
    pub fn std_vec_singleton<X: Ord + Clone>(x: &X) -> std_Vec<X> {
        std_Vec{x: vec![x.clone()]}
    }
    
    pub fn std_vec_push<X: Ord+Clone>(v: &mut std_Vec<X>, x: &X) {
        v.push((*x).clone());
    }
    
    pub fn std_vec_push_imm<X: Ord+Clone>(v: &std_Vec<X>, x: &X) -> std_Vec<X> {
        let mut v2 = v.clone();
        v2.push((*x).clone());
        v2
    }
    
    pub fn std_vec_contains<X: Ord>(v: &std_Vec<X>, x: &X) -> bool {
        v.x.contains(x)
    }
    
    pub fn std_vec_is_empty<X: Ord>(v: &std_Vec<X>) -> bool {
        v.x.is_empty()
    }
    
    pub fn std_vec_nth<X: Ord + Clone>(v: &std_Vec<X>, n: &u64) -> std_Option<X> {
        option2std(v.x.get(*n as usize).cloned())
    }
    
    pub fn std_vec2set<X: Ord + Clone>(s: &std_Vec<X>) -> std_Set<X> {
        std_Set{x: s.x.iter().cloned().collect()}
    }
    
    // Set
    
    #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
    pub struct std_Set<T: Ord> {
        pub x: BTreeSet<T>
    }
    
    /* This is needed so we can support for-loops over `Set`'s
     */
    pub struct SetIter<'a, X> {
        iter: btree_set::Iter<'a, X>
    }
    
    impl<'a, X: Ord> SetIter<'a, X> {
        pub fn new(set: &'a std_Set<X>) -> SetIter<'a, X> {
            SetIter{iter: set.x.iter()}
        }
    }
    
    impl<'a, X> Iterator for SetIter<'a, X> {
        type Item = &'a X;
    
        fn next(&mut self) -> Option<Self::Item> {
            self.iter.next()
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl <'a, T: Ord> std_Set<T> {
        pub fn iter(&'a self) -> SetIter<'a, T> {
            SetIter::new(self)
        }
    }
    
    impl <T: Ord> std_Set<T> {
        pub fn new() -> Self {
            std_Set{x: BTreeSet::new()}
        }
        pub fn insert(&mut self, v: T) {
            self.x.insert(v);
        }
    }
    
    impl<T: FromRecord + Ord> FromRecord for std_Set<T> {
        fn from_record(val: &Record) -> Result<Self, String> {
            BTreeSet::from_record(val).map(|x|std_Set{x})
        }
    }
    
    impl<T: IntoRecord + Ord> IntoRecord for std_Set<T> {
        fn into_record(self) -> Record {
            self.x.into_record()
        }
    }
    
    impl<T: FromRecord + Ord> Mutator<std_Set<T>> for Record
    {
        fn mutate(&self, set: &mut std_Set<T>) -> Result<(), String> {
            self.mutate(&mut set.x)
        }
    }
    
    impl<T: Ord> IntoIterator for std_Set<T> {
        type Item = T;
        type IntoIter = btree_set::IntoIter<T>;
        fn into_iter(self) -> Self::IntoIter {
            self.x.into_iter()
        }
    }
    
    impl<T: Ord> FromIterator<T> for std_Set<T> {
        fn from_iter<I>(iter: I) -> Self
        where I: IntoIterator<Item = T>
        {
            std_Set{x: BTreeSet::from_iter(iter)}
        }
    }
    
    impl<T: Display + Ord> Display for std_Set<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{}", *v))?;
                if i < len-1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<T: fmt::Debug + Ord> fmt::Debug for std_Set<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{:?}", *v))?;
                if i < len-1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    #[cfg(feature="flatbuf")]
    impl <'a,T,F> FromFlatBuffer<fbrt::Vector<'a,F>> for std_Set<T>
    where
    T: Ord+FromFlatBuffer<F::Inner>,
    F: fbrt::Follow<'a> + 'a,
    {
        fn from_flatbuf(fb: fbrt::Vector<'a,F>) -> Response<Self> {
            let mut set = std_Set::new();
            for x in FBIter::from_vector(fb) {
                set.insert(T::from_flatbuf(x)?);
            };
            Ok(set)
        }
    }
    
    // For scalar types, the FlatBuffers API returns slice instead of 'Vector'.
    #[cfg(feature="flatbuf")]
    impl <'a,T> FromFlatBuffer<&'a [T]> for std_Set<T>
    where
    T: Ord + Clone
    {
        fn from_flatbuf(fb: &'a [T]) -> Response<Self> {
            let mut set = std_Set::new();
            for x in fb.iter() {
                set.insert(x.clone());
            };
            Ok(set)
        }
    }
    
    #[cfg(feature="flatbuf")]
    impl <'b, T> ToFlatBuffer<'b> for std_Set<T>
    where
    T: Ord + ToFlatBufferVectorElement<'b>,
    {
        type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T::Target as fbrt::Push>::Output>>;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            let vec: Vec<T::Target> = self.iter().map(|x|x.to_flatbuf_vector_element(fbb)).collect();
            fbb.create_vector(vec.as_slice())
        }
    }
    
    pub fn std_set_size<X: Ord + Clone>(s: &std_Set<X>) -> u64 {
        s.x.len() as u64
    }
    
    pub fn std_set_empty<X: Ord + Clone>() -> std_Set<X> {
        std_Set::new()
    }
    
    pub fn std_set_singleton<X: Ord + Clone>(v: &X) -> std_Set<X> {
        let mut s = std_Set::new();
        s.insert(v.clone());
        s
    }
    
    pub fn std_set_insert<X: Ord+Clone>(s: &mut std_Set<X>, v: &X) {
        s.x.insert((*v).clone());
    }
    
    pub fn std_set_insert_imm<X: Ord+Clone>(s: &std_Set<X>, v: &X) -> std_Set<X> {
        let mut s2 = s.clone();
        s2.insert((*v).clone());
        s2
    }
    
    pub fn std_set_contains<X: Ord>(s: &std_Set<X>, v: &X) -> bool {
        s.x.contains(v)
    }
    
    pub fn std_set_is_empty<X: Ord>(s: &std_Set<X>) -> bool {
        s.x.is_empty()
    }
    
    pub fn std_set_nth<X: Ord + Clone>(s: &std_Set<X>, n: &u64) -> std_Option<X> {
        option2std(s.x.iter().nth(*n as usize).cloned())
    }
    
    pub fn std_set2vec<X: Ord + Clone>(s: &std_Set<X>) -> std_Vec<X> {
        std_Vec{x: s.x.iter().cloned().collect()}
    }
    
    pub fn std_set_union<X: Ord + Clone>(s1: &std_Set<X>, s2: &std_Set<X>) -> std_Set<X> {
        let mut s = s1.clone();
        s.x.append(&mut s2.x.clone());
        s
    }
    
    pub fn std_set_unions<X: Ord + Clone>(sets: &std_Vec<std_Set<X>>) -> std_Set<X> {
        let mut s = BTreeSet::new();
        for si in sets.x.iter() {
            s.append(&mut si.x.clone());
        };
        std_Set{x: s}
    }
    
    
    // Map
    
    #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
    pub struct std_Map<K: Ord,V> {
        pub x: BTreeMap<K,V>
    }
    
    /* This is needed so we can support for-loops over `Map`'s
     */
    pub struct MapIter<'a, K, V> {
        iter: btree_map::Iter<'a, K, V>
    }
    
    impl<'a, K: Ord, V> MapIter<'a, K, V> {
        pub fn new(map: &'a std_Map<K, V>) -> MapIter<'a, K, V> {
            MapIter{iter: map.x.iter()}
        }
    }
    
    impl<'a, K, V> Iterator for MapIter<'a, K, V> {
        type Item = (&'a K, &'a V);
    
        fn next(&mut self) -> Option<Self::Item> {
            self.iter.next()
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl <'a, K: Ord, V> std_Map<K, V> {
        pub fn iter(&'a self) -> MapIter<'a, K, V> {
            MapIter::new(self)
        }
    }
    
    impl <K: Ord, V> std_Map<K,V> {
        pub fn new() -> Self {
            std_Map{x: BTreeMap::new()}
        }
        pub fn insert(&mut self, k: K, v: V) {
            self.x.insert(k,v);
        }
    }
    
    impl<K: FromRecord+Ord, V: FromRecord> FromRecord for std_Map<K,V> {
        fn from_record(val: &Record) -> Result<Self, String> {
            BTreeMap::from_record(val).map(|x|std_Map{x})
        }
    }
    
    impl<K: IntoRecord + Ord, V: IntoRecord> IntoRecord for std_Map<K,V> {
        fn into_record(self) -> Record {
            self.x.into_record()
        }
    }
    
    impl<K: FromRecord + Ord, V: FromRecord + PartialEq> Mutator<std_Map<K,V>> for Record
    {
        fn mutate(&self, map: &mut std_Map<K,V>) -> Result<(), String> {
            self.mutate(&mut map.x)
        }
    }
    
    impl<K: Ord,V> IntoIterator for std_Map<K,V> {
        type Item = (K,V);
        type IntoIter = btree_map::IntoIter<K,V>;
        fn into_iter(self) -> Self::IntoIter {
            self.x.into_iter()
        }
    }
    
    impl<K: Ord, V> FromIterator<(K,V)> for std_Map<K,V> {
        fn from_iter<I>(iter: I) -> Self
        where I: IntoIterator<Item = (K,V)>
        {
            std_Map{x: BTreeMap::from_iter(iter)}
        }
    }
    
    impl<K: Display+Ord, V: Display> Display for std_Map<K,V> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, (k,v)) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("({},{})", *k, *v))?;
                if i < len-1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<K: fmt::Debug+Ord, V: fmt::Debug> fmt::Debug for std_Map<K,V> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, (k,v)) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("({:?},{:?})", *k, *v))?;
                if i < len-1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    #[cfg(feature="flatbuf")]
    impl <'a,K,V,F> FromFlatBuffer<fbrt::Vector<'a,F>> for std_Map<K,V>
    where
    F: fbrt::Follow<'a> + 'a,
    K: Ord,
    (K,V): FromFlatBuffer<F::Inner>
    {
        fn from_flatbuf(fb: fbrt::Vector<'a,F>) -> Response<Self> {
            let mut m = std_Map::new();
            for x in FBIter::from_vector(fb) {
                let (k,v) = <(K,V)>::from_flatbuf(x)?;
                m.insert(k,v);
            };
            Ok(m)
        }
    }
    
    #[cfg(feature="flatbuf")]
    impl <'b, K, V, T> ToFlatBuffer<'b> for std_Map<K, V>
    where
    K: Ord + Clone,
    V: Clone,
    (K,V): ToFlatBufferVectorElement<'b, Target=T>,
    T: 'b + fbrt::Push + Copy
    {
        type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T as fbrt::Push>::Output>>;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            let vec: Vec<<(K,V) as ToFlatBufferVectorElement<'b>>::Target> =
                self.iter().map(|(k,v)|((*k).clone(), (*v).clone()).to_flatbuf_vector_element(fbb)).collect();
            fbb.create_vector(vec.as_slice())
        }
    }
    
    pub fn std_map_empty<K: Ord + Clone,V: Clone>() -> std_Map<K, V> {
        std_Map::new()
    }
    
    pub fn std_map_singleton<K: Ord + Clone,V: Clone>(k: &K, v: &V) -> std_Map<K, V> {
        let mut m = std_Map::new();
        m.insert(k.clone(), v.clone());
        m
    }
    
    pub fn std_map_insert<K: Ord+Clone, V: Clone>(m: &mut std_Map<K,V>, k: &K, v: &V) {
        m.x.insert((*k).clone(), (*v).clone());
    }
    
    pub fn std_map_remove<K: Ord+Clone, V: Clone>(m: &mut std_Map<K,V>, k: &K) {
        m.x.remove(k);
    }
    
    pub fn std_map_insert_imm<K: Ord+Clone, V: Clone>(m: &std_Map<K,V>, k: &K, v: &V) -> std_Map<K,V> {
        let mut m2 = m.clone();
        m2.insert((*k).clone(), (*v).clone());
        m2
    }
    
    pub fn std_map_get<K: Ord, V: Clone>(m: &std_Map<K,V>, k: &K) -> std_Option<V> {
        option2std(m.x.get(k).cloned())
    }
    
    pub fn std_map_contains_key<K: Ord, V: Clone>(s: &std_Map<K,V>, k: &K) -> bool {
        s.x.contains_key(k)
    }
    
    pub fn std_map_is_empty<K: Ord, V: Clone>(m: &std_Map<K,V>) -> bool {
        m.x.is_empty()
    }
    
    pub fn std_map_union<K: Ord + Clone,V: Clone>(m1: &std_Map<K,V>, m2: &std_Map<K,V>) -> std_Map<K, V> {
        let mut m = m1.clone();
        m.x.append(&mut m2.x.clone());
        m
    }
    
    
    // strings
    
    pub fn std___builtin_2string<T: Display>(x: &T) -> String {
        format!("{}", *x).to_string()
    }
    
    pub fn std_hex<T: fmt::LowerHex>(x: &T) -> String {
        format!("{:x}", *x).to_string()
    }
    
    pub fn std_parse_dec_u64(s: &String) -> std_Option<u64> {
        option2std(s.parse::<u64>().ok())
    }
    
    pub fn std_parse_dec_i64(s: &String) -> std_Option<i64> {
        option2std(s.parse::<i64>().ok())
    }
    
    pub fn std_string_join(strings: &std_Vec<String>, sep: &String) -> String {
        strings.x.join(sep.as_str())
    }
    
    pub fn std_string_split(s: &String, sep: &String) -> std_Vec<String> {
        std_Vec{x: s.split(sep).map(|x| x.to_owned()).collect()}
    }
    
    pub fn std_string_contains(s1: &String, s2: &String) -> bool {
        s1.contains(s2.as_str())
    }
    
    pub fn std_string_substr(s: &String, start: &u64, end: &u64) -> String {
        let len = s.len();
        let from = cmp::min(*start as usize, len);
        let to = cmp::max(from, cmp::min(*end as usize, len));
        s[from..to].to_string()
    }
    
    pub fn std_string_len(s: &String) -> u64 {
        s.len() as u64
    }
    
    pub fn std_str_to_lower(s: &String) -> String {
        s.to_lowercase()
    }
    
    // Hashing
    
    pub fn std_hash64<T: Hash>(x: &T) -> u64 {
        let mut hasher = XxHash::with_seed(XX_SEED1);
        x.hash(&mut hasher);
        hasher.finish()
    }
    
    pub fn std_hash128<T: Hash>(x: &T) -> u128 {
        let mut hasher = XxHash::with_seed(XX_SEED1);
        x.hash(&mut hasher);
        let w1 = hasher.finish();
        let mut hasher = XxHash::with_seed(XX_SEED2);
        x.hash(&mut hasher);
        let w2 = hasher.finish();
        ((w1 as u128) << 64) | (w2 as u128)
    }
    
    pub type ProjectFunc<X> = fn(&Value) -> X;
    
    /*
     * Group type (used in aggregation operators)
     */
    pub struct std_Group<'a, X> {
        /* TODO: remove "pub" */
        pub group: &'a [(&'a Value, Weight)],
        pub project: &'a ProjectFunc<X>
    }
    
    /* This is needed so we can support for-loops over `Group`'s
     */
    pub struct GroupIter<'a, X> {
        iter: slice::Iter<'a, (&'a Value, Weight)>,
        project: &'a ProjectFunc<X>
    }
    
    impl<'a, X> GroupIter<'a, X> {
        pub fn new(grp: &std_Group<'a, X>) -> GroupIter<'a, X> {
            GroupIter{iter: grp.group.iter(), project: grp.project}
        }
    }
    
    impl<'a, X> Iterator for GroupIter<'a, X> {
        type Item = X;
    
        fn next(&mut self) -> Option<Self::Item> {
            match self.iter.next() {
                None => None,
                Some((x,_)) => Some((self.project)(x))
            }
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl<'a, X> std_Group<'a, X> {
        pub fn new(group: &'a[(&'a Value, Weight)], project: &'static ProjectFunc<X>) -> std_Group<'a, X> {
            std_Group{group: group, project: project}
        }
    
        fn size(&self) -> u64 {
            self.group.len() as u64
        }
    
        fn first(&'a self) -> X {
            (self.project)(self.group[0].0)
        }
    
        fn nth_unchecked(&'a self, n: u64) -> X {
            (self.project)(self.group[n as usize].0)
        }
    
        pub fn iter(&'a self) -> GroupIter<'a, X> {
            GroupIter::new(self)
        }
    }
    
    impl<'a, X> std_Group<'a, X> {
        fn nth(&'a self, n: u64) -> std_Option<X> {
            if self.size() > n {
                std_Option::std_Some{x: (self.project)(self.group[n as usize].0)}
            } else {
                std_Option::std_None
            }
        }
    }
    
    /*
     * Standard aggregation function
     */
    pub fn std_group_count<A>(g: &std_Group<A>) -> u64 {
        g.size()
    }
    
    pub fn std_group_first<A>(g: &std_Group<A>) -> A {
        g.first()
    }
    
    pub fn std_group_nth<A>(g: &std_Group<A>, n: &u64) -> std_Option<A> {
        g.nth(*n)
    }
    
    pub fn std_group2set<A: Ord + Clone>(g: &std_Group<A>) -> std_Set<A> {
        let mut res = std_Set::new();
        for v in g.iter() {
            std_set_insert(&mut res, &v);
        };
        res
    }
    
    pub fn std_group_set_unions<A: Ord + Clone>(g: &std_Group<std_Set<A>>) -> std_Set<A>
    {
        let mut res = std_Set::new();
        for gr in g.iter() {
            for v in gr.iter() {
               std_set_insert(&mut res, v);
            }
        };
        res
    }
    
    pub fn std_group_setref_unions<A: Ord + Clone>(g: &std_Group<std_Ref<std_Set<A>>>)
        -> std_Ref<std_Set<A>>
    {
        if g.size() == 1 {
            g.first()
        } else {
            let mut res: std_Ref<std_Set<A>> = std_ref_new(&std_Set::new());
            {
                let mut rres = std_Ref::get_mut(&mut res).unwrap();
                for gr in g.iter() {
                    for v in gr.iter() {
                        std_set_insert(&mut rres, &v);
                    }
                };
            }
            res
        }
    }
    
    pub fn std_group2vec<A: Ord + Clone>(g: &std_Group<A>) -> std_Vec<A>
    {
        let mut res = std_Vec::with_capacity(g.size() as usize);
        for v in g.iter() {
            std_vec_push(&mut res, &v);
        };
        res
    }
    
    pub fn std_group2map<K: Ord + Clone, V: Clone>(g: &std_Group<(K,V)>) -> std_Map<K,V>
    {
        let mut res = std_Map::new();
        for (k, v) in g.iter() {
            std_map_insert(&mut res, &k, &v);
        };
        res
    }
    
    pub fn std_group_min<A: Ord>(g: &std_Group<A>) -> A {
        g.iter().min().unwrap()
    }
    
    pub fn std_group_max<A: Ord>(g: &std_Group<A>) -> A {
        g.iter().max().unwrap()
    }
    
    pub fn std_group_sum<A: ops::Add + ops::AddAssign>(g: &std_Group<A>) -> A {
        let mut res = std_group_first(g);
        for v in g.iter().skip(1) {
            res += v;
        };
        res
    }
    
    /* Tuples */
    #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
    pub struct tuple0;
    
    impl FromRecord for tuple0 {
        fn from_record(val: &Record) -> Result<Self, String> {
            <()>::from_record(val).map(|_|tuple0)
        }
    }
    
    impl IntoRecord for tuple0 {
        fn into_record(self) -> Record {
            ().into_record()
        }
    }
    
    macro_rules! decl_tuple {
        ( $name:ident, $( $t:tt ),+ ) => {
            #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
            pub struct $name< $($t),* >($(pub $t),*);
            impl <$($t: FromRecord),*> FromRecord for $name<$($t),*> {
                fn from_record(val: &Record) -> Result<Self, String> {
                    <($($t),*)>::from_record(val).map(|($($t),*)|$name($($t),*))
                }
            }
    
            impl <$($t: IntoRecord),*> IntoRecord for $name<$($t),*> {
                fn into_record(self) -> Record {
                    let $name($($t),*) = self;
                    Record::Tuple(vec![$($t.into_record()),*])
                }
            }
    
            impl <$($t: FromRecord),*> Mutator<$name<$($t),*>> for Record {
                fn mutate(&self, x: &mut $name<$($t),*>) -> Result<(), String> {
                    *x = <$name<$($t),*>>::from_record(self)?;
                    Ok(())
                }
            }
        };
    }
    
    decl_tuple!(tuple2,  T1, T2);
    decl_tuple!(tuple3,  T1, T2, T3);
    decl_tuple!(tuple4,  T1, T2, T3, T4);
    decl_tuple!(tuple5,  T1, T2, T3, T4, T5);
    decl_tuple!(tuple6,  T1, T2, T3, T4, T5, T6);
    decl_tuple!(tuple7,  T1, T2, T3, T4, T5, T6, T7);
    decl_tuple!(tuple8,  T1, T2, T3, T4, T5, T6, T7, T8);
    decl_tuple!(tuple9,  T1, T2, T3, T4, T5, T6, T7, T8, T9);
    decl_tuple!(tuple10, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10);
    decl_tuple!(tuple11, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11);
    decl_tuple!(tuple12, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);
    decl_tuple!(tuple13, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13);
    decl_tuple!(tuple14, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14);
    decl_tuple!(tuple15, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15);
    decl_tuple!(tuple16, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16);
    decl_tuple!(tuple17, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17);
    decl_tuple!(tuple18, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18);
    decl_tuple!(tuple19, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19);
    decl_tuple!(tuple20, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20);
    
    // Endianness
    pub fn std_ntohl(x: &u32) -> u32 {
        u32::from_be(*x)
    }
    
    pub fn std_ntohs(x: &u16) -> u16 {
        u16::from_be(*x)
    }
    
    pub fn std_htonl(x: &u32) -> u32 {
        u32::to_be(*x)
    }
    
    pub fn std_htons(x: &u16) -> u16 {
        u16::to_be(*x)
    }
}
pub use __log::*;
mod __log {
    use super::*;
    use std::sync;
    use std::collections;
    use std::ffi;
    
    type log_callback_t = Box<dyn Fn(log_log_level_t, &str) + Send + Sync>;
    
    lazy_static! {
        /* Logger configuration for each module consists of the maximal enabled
         * log level (messages above this level are ignored) and callback.
         */
        static ref LOG_CONFIG: sync::RwLock<collections::HashMap<log_module_t, (log_callback_t, log_log_level_t)>> = {
            sync::RwLock::new(collections::HashMap::new())
        };
    }
    
    /*
     * Logging API exposed to the DDlog program.
     * (see detailed documentation in `log.dl`)
     */
    pub fn log_log(module: &log_module_t, level: &log_log_level_t, msg: &String) -> bool
    {
        if let Some((cb, current_level)) = LOG_CONFIG.read().unwrap().get(&module) {
            if *level <= *current_level {
                cb(*level, msg.as_str());
            }
        };
        true
    }
    
    /*
     * Configuration API
     * (detailed documentation in `ddlog_log.h`)
     *
     * `cb = None` - disables logging for the given module.
     *
     * NOTE: we set callback and log level simultaneously.  A more flexible API
     * would allow changing log level without changing the callback.
     */
    pub fn log_set_callback(module: log_module_t, cb: Option<log_callback_t>, max_level: log_log_level_t)
    {
        match cb {
            Some(cb) => {
                LOG_CONFIG.write().unwrap().insert(module, (cb, max_level));
            },
            None => {
                LOG_CONFIG.write().unwrap().remove(&module);
            }
        }
    }
    
    /*
     * C bindings for the config API
     */
    #[no_mangle]
    pub unsafe extern "C" fn ddlog_log_set_callback(module: raw::c_int,
                                                    cb: Option<extern "C" fn(arg: libc::uintptr_t,
                                                                             level: raw::c_int,
                                                                             msg: *const raw::c_char)>,
                                                    cb_arg: libc::uintptr_t,
                                                    max_level: raw::c_int)
    {
        match cb {
            Some(cb) => {
                log_set_callback(module as log_module_t,
                                 Some(Box::new(move |level, msg| {
                                     cb(cb_arg,
                                        level as raw::c_int,
                                        ffi::CString::new(msg).unwrap_or_default().as_ptr())
                                 })),
                                 max_level as log_log_level_t)
            },
            None => {
                log_set_callback(module as log_module_t,
                                 None,
                                 max_level as log_log_level_t)
            }
        }
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct FwdTable {
    vip: types_VIP,
    ip: types_IP
}
impl Abomonation for FwdTable{}
impl <> record::FromRecord for FwdTable<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, args) => {
                match constr.as_ref() {
                    "FwdTable" if args.len() == 2 => {
                        Ok(FwdTable{vip: <types_VIP>::from_record(&args[0])?, ip: <types_IP>::from_record(&args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type FwdTable in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, args) => {
                match constr.as_ref() {
                    "FwdTable" => {
                        Ok(FwdTable{vip: record::arg_extract::<types_VIP>(args, "vip")?, ip: record::arg_extract::<types_IP>(args, "ip")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type FwdTable in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(FwdTable, <>, vip, ip);
decl_record_mutator_struct!(FwdTable, <>, vip: types_VIP, ip: types_IP);
impl fmt::Display for FwdTable {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FwdTable{vip,ip} => {
                __formatter.write_str("FwdTable{")?;
                fmt::Debug::fmt(vip, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ip, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for FwdTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct Host {
    id: types_UUID,
    ip: types_IP
}
impl Abomonation for Host{}
impl <> record::FromRecord for Host<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, args) => {
                match constr.as_ref() {
                    "Host" if args.len() == 2 => {
                        Ok(Host{id: <types_UUID>::from_record(&args[0])?, ip: <types_IP>::from_record(&args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Host in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, args) => {
                match constr.as_ref() {
                    "Host" => {
                        Ok(Host{id: record::arg_extract::<types_UUID>(args, "id")?, ip: record::arg_extract::<types_IP>(args, "ip")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Host in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Host, <>, id, ip);
decl_record_mutator_struct!(Host, <>, id: types_UUID, ip: types_IP);
impl fmt::Display for Host {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Host{id,ip} => {
                __formatter.write_str("Host{")?;
                fmt::Debug::fmt(id, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ip, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Host {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct VM {
    vip: types_VIP,
    host: types_UUID
}
impl Abomonation for VM{}
impl <> record::FromRecord for VM<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, args) => {
                match constr.as_ref() {
                    "VM" if args.len() == 2 => {
                        Ok(VM{vip: <types_VIP>::from_record(&args[0])?, host: <types_UUID>::from_record(&args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type VM in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, args) => {
                match constr.as_ref() {
                    "VM" => {
                        Ok(VM{vip: record::arg_extract::<types_VIP>(args, "vip")?, host: record::arg_extract::<types_UUID>(args, "host")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type VM in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(VM, <>, vip, host);
decl_record_mutator_struct!(VM, <>, vip: types_VIP, host: types_UUID);
impl fmt::Display for VM {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            VM{vip,host} => {
                __formatter.write_str("VM{")?;
                fmt::Debug::fmt(vip, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(host, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for VM {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
type log_log_level_t = i32;
type log_module_t = i32;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum std_Either<A, B> {
    std_Left {
        l: A
    },
    std_Right {
        r: B
    }
}
impl <A: Val, B: Val> Abomonation for std_Either<A, B>{}
impl <A: record::FromRecord + Default,B: record::FromRecord + Default> record::FromRecord for std_Either<A,B> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, args) => {
                match constr.as_ref() {
                    "std.Left" if args.len() == 1 => {
                        Ok(std_Either::std_Left{l: <A>::from_record(&args[0])?})
                    },
                    "std.Right" if args.len() == 1 => {
                        Ok(std_Either::std_Right{r: <B>::from_record(&args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type std_Either in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, args) => {
                match constr.as_ref() {
                    "std.Left" => {
                        Ok(std_Either::std_Left{l: record::arg_extract::<A>(args, "l")?})
                    },
                    "std.Right" => {
                        Ok(std_Either::std_Right{r: record::arg_extract::<B>(args, "r")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type std_Either in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(std_Either, <A,B>, std_Left{l}, std_Right{r});
decl_record_mutator_enum!(std_Either, <A,B>, std_Left{l: A}, std_Right{r: B});
impl <A: fmt::Debug, B: fmt::Debug> fmt::Display for std_Either<A, B> {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            std_Either::std_Left{l} => {
                __formatter.write_str("std.Left{")?;
                fmt::Debug::fmt(l, __formatter)?;
                __formatter.write_str("}")
            },
            std_Either::std_Right{r} => {
                __formatter.write_str("std.Right{")?;
                fmt::Debug::fmt(r, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl <A: fmt::Debug, B: fmt::Debug> fmt::Debug for std_Either<A, B> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  <A: Default, B: Default> Default for std_Either<A, B> {
    fn default() -> Self {
        std_Either::std_Left{l : Default::default()}
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum std_Option<A> {
    std_Some {
        x: A
    },
    std_None
}
impl <A: Val> Abomonation for std_Option<A>{}
impl <A: record::FromRecord + Default> record::FromRecord for std_Option<A> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, args) => {
                match constr.as_ref() {
                    "std.Some" if args.len() == 1 => {
                        Ok(std_Option::std_Some{x: <A>::from_record(&args[0])?})
                    },
                    "std.None" if args.len() == 0 => {
                        Ok(std_Option::std_None{})
                    },
                    c => Result::Err(format!("unknown constructor {} of type std_Option in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, args) => {
                match constr.as_ref() {
                    "std.Some" => {
                        Ok(std_Option::std_Some{x: record::arg_extract::<A>(args, "x")?})
                    },
                    "std.None" => {
                        Ok(std_Option::std_None{})
                    },
                    c => Result::Err(format!("unknown constructor {} of type std_Option in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(std_Option, <A>, std_Some{x}, std_None{});
decl_record_mutator_enum!(std_Option, <A>, std_Some{x: A}, std_None{});
impl <A: fmt::Debug> fmt::Display for std_Option<A> {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            std_Option::std_Some{x} => {
                __formatter.write_str("std.Some{")?;
                fmt::Debug::fmt(x, __formatter)?;
                __formatter.write_str("}")
            },
            std_Option::std_None{} => {
                __formatter.write_str("std.None{")?;
                __formatter.write_str("}")
            }
        }
    }
}
impl <A: fmt::Debug> fmt::Debug for std_Option<A> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  <A: Default> Default for std_Option<A> {
    fn default() -> Self {
        std_Option::std_Some{x : Default::default()}
    }
}
type types_IP = u32;
type types_UUID = u128;
type types_VIP = u32;
pub fn relname2id(rname: &str) -> Option<Relations> {
   match rname {
        "FwdTable" => Some(Relations::FwdTable),
        "Host" => Some(Relations::Host),
        "VM" => Some(Relations::VM),
       _  => None
   }
}
pub fn output_relname_to_id(rname: &str) -> Option<Relations> {
   match rname {
        "FwdTable" => Some(Relations::FwdTable),
       _  => None
   }
}
pub fn input_relname_to_id(rname: &str) -> Option<Relations> {
   match rname {
        "Host" => Some(Relations::Host),
        "VM" => Some(Relations::VM),
       _  => None
   }
}
pub fn relid2rel(rid: RelId) -> Option<Relations> {
   match rid {
        0 => Some(Relations::FwdTable),
        1 => Some(Relations::Host),
        2 => Some(Relations::VM),
       _  => None
   }
}
pub fn relid2name(rid: RelId) -> Option<&'static str> {
   match rid {
        0 => Some(&"FwdTable"),
        1 => Some(&"Host"),
        2 => Some(&"VM"),
       _  => None
   }
}
lazy_static! {
    pub static ref RELIDMAP: FnvHashMap<Relations, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Relations::FwdTable, "FwdTable");
        m.insert(Relations::Host, "Host");
        m.insert(Relations::VM, "VM");
        m
   };
}
lazy_static! {
    pub static ref INPUT_RELIDMAP: FnvHashMap<Relations, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Relations::Host, "Host");
        m.insert(Relations::VM, "VM");
        m
    };
}
lazy_static! {
    pub static ref OUTPUT_RELIDMAP: FnvHashMap<Relations, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Relations::FwdTable, "FwdTable");
        m
    };
}
pub fn relval_from_record(rel: Relations, rec: &record::Record) -> Result<Value, String> {
    match rel {
        Relations::FwdTable => {
            Ok(Value::FwdTable(<FwdTable>::from_record(rec)?))
        },
        Relations::Host => {
            Ok(Value::Host(boxed::Box::new(<Host>::from_record(rec)?)))
        },
        Relations::VM => {
            Ok(Value::VM(boxed::Box::new(<VM>::from_record(rec)?)))
        }
    }
}
pub fn relkey_from_record(rel: Relations, rec: &record::Record) -> Result<Value, String> {
    match rel {
        _ => Err(format!("relation {:?} does not have a primary key", rel))
    }
}
#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]
pub enum Relations {
    FwdTable = 0,
    Host = 1,
    VM = 2
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub enum Value {
    bit128(u128),
    tuple0__(()),
    FwdTable(FwdTable),
    Host(boxed::Box<Host>),
    VM(boxed::Box<VM>)
}
unsafe_abomonate!(Value);
impl Default for Value {
    fn default() -> Value {Value::tuple0__(())}
}
impl fmt::Display for Value {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Value::bit128 (v) => write!(f, "{:?}", *v),
            Value::tuple0__ (v) => write!(f, "{:?}", *v),
            Value::FwdTable (v) => write!(f, "{:?}", *v),
            Value::Host (v) => write!(f, "{:?}", *v),
            Value::VM (v) => write!(f, "{:?}", *v)
        }
    }
}
decl_val_enum_into_record!(Value, <>, bit128(x), tuple0__(x), FwdTable(x), Host(x), VM(x));
decl_record_mutator_val_enum!(Value, <>, bit128(u128), tuple0__(()), FwdTable(FwdTable), Host(Host), VM(VM));
/* fn log_log(module: & log_module_t, level: & log_log_level_t, msg: & String) -> bool */
/* fn std___builtin_2string<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> String */
/* fn std_deref<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & std_Ref<A>) -> A */
/* fn std_group2map<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<(K, V)>) -> std_Map<K, V> */
/* fn std_group2set<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> std_Set<A> */
/* fn std_group2vec<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> std_Vec<A> */
/* fn std_group_count<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> u64 */
/* fn std_group_first<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> A */
/* fn std_group_max<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> A */
/* fn std_group_min<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> A */
/* fn std_group_nth<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>, n: & u64) -> std_Option<A> */
/* fn std_group_set_unions<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<std_Set<A>>) -> std_Set<A> */
/* fn std_group_setref_unions<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<std_Ref<std_Set<A>>>) -> std_Ref<std_Set<A>> */
/* fn std_group_sum<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> A */
/* fn std_hash128<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> u128 */
/* fn std_hash64<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> u64 */
/* fn std_hex<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> String */
/* fn std_htonl(x: & u32) -> u32 */
/* fn std_htons(x: & u16) -> u16 */
/* fn std_map_contains_key<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: & std_Map<K, V>, k: & K) -> bool */
/* fn std_map_empty<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>() -> std_Map<K, V> */
/* fn std_map_get<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: & std_Map<K, V>, k: & K) -> std_Option<V> */
/* fn std_map_insert<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: &mut std_Map<K, V>, k: & K, v: & V) -> () */
/* fn std_map_insert_imm<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: & std_Map<K, V>, k: & K, v: & V) -> std_Map<K, V> */
/* fn std_map_is_empty<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: & std_Map<K, V>) -> bool */
/* fn std_map_remove<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: &mut std_Map<K, V>, k: & K) -> () */
/* fn std_map_singleton<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(k: & K, v: & V) -> std_Map<K, V> */
/* fn std_map_union<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m1: & std_Map<K, V>, m2: & std_Map<K, V>) -> std_Map<K, V> */
/* fn std_max<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & A, y: & A) -> A */
/* fn std_min<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & A, y: & A) -> A */
/* fn std_ntohl(x: & u32) -> u32 */
/* fn std_ntohs(x: & u16) -> u16 */
/* fn std_parse_dec_i64(s: & String) -> std_Option<i64> */
/* fn std_parse_dec_u64(s: & String) -> std_Option<u64> */
/* fn std_pow32<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(base: & A, exp: & u32) -> A */
/* fn std_range<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(from: & A, to: & A, step: & A) -> std_Vec<A> */
/* fn std_ref_new<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & A) -> std_Ref<A> */
/* fn std_set2vec<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<A>) -> std_Vec<A> */
/* fn std_set_contains<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>, v: & X) -> bool */
/* fn std_set_empty<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>() -> std_Set<X> */
/* fn std_set_insert<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: &mut std_Set<X>, v: & X) -> () */
/* fn std_set_insert_imm<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>, v: & X) -> std_Set<X> */
/* fn std_set_is_empty<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>) -> bool */
/* fn std_set_nth<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>, n: & u64) -> std_Option<X> */
/* fn std_set_singleton<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> std_Set<X> */
/* fn std_set_size<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>) -> u64 */
/* fn std_set_union<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s1: & std_Set<X>, s2: & std_Set<X>) -> std_Set<X> */
/* fn std_set_unions<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(sets: & std_Vec<std_Set<X>>) -> std_Set<X> */
/* fn std_str_to_lower(s: & String) -> String */
/* fn std_string_contains(s1: & String, s2: & String) -> bool */
/* fn std_string_join(strings: & std_Vec<String>, sep: & String) -> String */
/* fn std_string_len(s: & String) -> u64 */
/* fn std_string_split(s: & String, sep: & String) -> std_Vec<String> */
/* fn std_string_substr(s: & String, start: & u64, end: & u64) -> String */
/* fn std_vec2set<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Vec<A>) -> std_Set<A> */
/* fn std_vec_contains<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>, x: & X) -> bool */
/* fn std_vec_empty<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>() -> std_Vec<A> */
/* fn std_vec_is_empty<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>) -> bool */
/* fn std_vec_len<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>) -> u64 */
/* fn std_vec_nth<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>, n: & u64) -> std_Option<X> */
/* fn std_vec_push<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: &mut std_Vec<X>, x: & X) -> () */
/* fn std_vec_push_imm<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>, x: & X) -> std_Vec<X> */
/* fn std_vec_singleton<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> std_Vec<X> */
fn std_group_unzip<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,Y: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<(X, Y)>) -> (std_Vec<X>, std_Vec<Y>)
{   let ref mut xs : std_Vec<X> = std_vec_empty();
    let ref mut ys : std_Vec<Y> = std_vec_empty();
    for ref v in g.iter() {
        {
            let (ref mut x, ref mut y) = v.clone();
            std_vec_push(xs, x);
            std_vec_push(ys, y)
        }
    };
    (xs.clone(), ys.clone())
}
fn std_is_none<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & std_Option<A>) -> bool
{   match (*x) {
        std_Option::std_None{} => true,
        _ => false
    }
}
fn std_is_some<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & std_Option<A>) -> bool
{   match (*x) {
        std_Option::std_Some{x: _} => true,
        _ => false
    }
}
pub fn prog(__update_cb: Box<dyn CBFn<Value>>) -> Program<Value> {
    let Host = Relation {
                   name:         "Host".to_string(),
                   input:        true,
                   distinct:     false,
                   key_func:     None,
                   id:           Relations::Host as RelId,
                   rules:        vec![
                       ],
                   arrangements: vec![
                       Arrangement::Map{
                          name: r###"Host{.id=_0, .ip=_}"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::Host(__box) = __v {
                                       match *__box {
                                       Host{id: ref _0, ip: _} => Some(Value::bit128(_0.clone())),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f}
                       }],
                   change_cb:    None
               };
    let VM = Relation {
                 name:         "VM".to_string(),
                 input:        true,
                 distinct:     false,
                 key_func:     None,
                 id:           Relations::VM as RelId,
                 rules:        vec![
                     ],
                 arrangements: vec![
                     Arrangement::Map{
                        name: r###"VM{.vip=_, .host=_0}"###.to_string(),
                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                         {
                             let __cloned = __v.clone();
                             {
                                 if let Value::VM(__box) = __v {
                                     match *__box {
                                     VM{vip: _, host: ref _0} => Some(Value::bit128(_0.clone())),
                                     _ => None
                                     }
                                 } else { None }
                             }.map(|x|(x,__cloned))
                         }
                         __f}
                     }],
                 change_cb:    None
             };
    let FwdTable = Relation {
                       name:         "FwdTable".to_string(),
                       input:        false,
                       distinct:     true,
                       key_func:     None,
                       id:           Relations::FwdTable as RelId,
                       rules:        vec![
                           /* FwdTable(.vip=vip, .ip=ip) :- VM(.vip=vip, .host=host), Host(.id=host, .ip=ip). */
                           Rule::ArrangementRule {
                               description: "FwdTable(.vip=vip, .ip=ip) :- VM(.vip=vip, .host=host), Host(.id=host, .ip=ip).".to_string(),
                               arr: ( Relations::VM as RelId, 0),
                               xform: XFormArrangement::Join{
                                          description: "VM(.vip=vip, .host=host), Host(.id=host, .ip=ip)".to_string(),
                                          ffun: None,
                                          arrangement: (Relations::Host as RelId,0),
                                          jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                          {
                                              let (vip, host) = match *__v1{
                                                  Value::VM(ref __box) => {
                                                      match **__box {
                                                      VM{vip: ref vip, host: ref host} => (vip, host),
                                                      _ => return None
                                                      }
                                                  },
                                                  _ => return None
                                              };
                                              let ip = match *__v2{
                                                  Value::Host(ref __box) => {
                                                      match **__box {
                                                      Host{id: _, ip: ref ip} => ip,
                                                      _ => return None
                                                      }
                                                  },
                                                  _ => return None
                                              };
                                              Some(Value::FwdTable(FwdTable{vip: vip.clone(), ip: ip.clone()}))
                                          }
                                          __f},
                                          next: Box::new(None)
                                      }
                           }],
                       arrangements: vec![
                           ],
                       change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                   };
    Program {
        nodes: vec![
            ProgNode::Rel{rel: Host},
            ProgNode::Rel{rel: VM},
            ProgNode::Rel{rel: FwdTable}
        ],
        init_data: vec![
        ]
    }
}